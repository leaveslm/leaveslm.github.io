<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从ConcurrentHashMap的演进看Java多线程核心技术]]></title>
    <url>%2F2018%2F09%2F04%2F2018-2018-09-04-%E4%BB%8EConcurrentHashMap%E7%9A%84%E6%BC%94%E8%BF%9B%E7%9C%8BJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[原创文章，转载请务必将下面这段话置于文章开头处（保留超链接）。本文转发自技术世界，原文链接 http://www.jasongj.com/java/concurrenthashmap/ 前言本文分析了HashMap的实现原理，以及resize可能引起死循环和Fast-fail等线程不安全行为。同时结合源码从数据结构，寻址方式，同步方式，计算size等角度分析了JDK 1.7和JDK 1.8中ConcurrentHashMap的实现原理。 线程不安全的HashMap众所周知，HashMap是非线程安全的。而HashMap的线程不安全主要体现在resize时的死循环及使用迭代器时的fast-fail上。注：本章的代码均基于JDK 1.7.0_67 HashMap工作原理HashMap数据结构常用的底层数据结构主要有数组和链表。数组存储区间连续，占用内存较多，寻址容易，插入和删除困难。链表存储区间离散，占用内存较少，寻址困难，插入和删除容易。 HashMap要实现的是哈希表的效果，尽量实现O(1)级别的增删改查。它的具体实现则是同时使用了数组和链表，可以认为最外层是一个数组，数组的每个元素是一个链表的表头。 HashMap寻址方式对于新插入的数据或者待读取的数据，HashMap将Key的哈希值对数组长度取模，结果作为该Entry在数组中的index。在计算机中，取模的代价远高于位操作的代价，因此HashMap要求数组的长度必须为2的N次方。此时将Key的哈希值对2^N-1进行与运算，其效果即与取模等效。HashMap并不要求用户在指定HashMap容量时必须传入一个2的N次方的整数，而是会通过Integer.highestOneBit算出比指定整数小的最大的2^N值，其实现方法如下。12345678public static int highestOneBit(int i) &#123; i |= (i &gt;&gt; 1); i |= (i &gt;&gt; 2); i |= (i &gt;&gt; 4); i |= (i &gt;&gt; 8); i |= (i &gt;&gt; 16); return i - (i &gt;&gt;&gt; 1);&#125; 由于Key的哈希值的分布直接决定了所有数据在哈希表上的分布或者说决定了哈希冲突的可能性，因此为防止糟糕的Key的hashCode实现（例如低位都相同，只有高位不相同，与2^N-1取与后的结果都相同），JDK 1.7的HashMap通过如下方法使得最终的哈希值的二进制形式中的1尽量均匀分布从而尽可能减少哈希冲突。1234int h = hashSeed;h ^= k.hashCode();h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); resize死循环transfer方法当HashMap的size超过Capacity*loadFactor时，需要对HashMap进行扩容。具体方法是，创建一个新的，长度为原来Capacity两倍的数组，保证新的Capacity仍为2的N次方，从而保证上述寻址方式仍适用。同时需要通过如下transfer方法将原来的所有数据全部重新插入（rehash）到新的数组中。123456789101112131415void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125;&#125; 该方法并不保证线程安全，而且在多线程并发调用时，可能出现死循环。其执行过程如下。从步骤2可见，转移时链表顺序反转。 遍历原数组中的元素 对链表上的每一个节点遍历：用next取得要转移那个元素的下一个，将e转移到新数组的头部，使用头插法插入节点 循环2，直到链表节点全部转移 循环1，直到所有元素全部转移 单线程rehash单线程情况下，rehash无问题。下图演示了单线程条件下的rehash过程 多线程并发下的rehash这里假设有两个线程同时执行了put操作并引发了rehash，执行了transfer方法，并假设线程一进入transfer方法并执行完next = e.next后，因为线程调度所分配时间片用完而“暂停”，此时线程二完成了transfer方法的执行。此时状态如下。接着线程1被唤醒，继续执行第一轮循环的剩余部分123e.next = newTable[1] = nullnewTable[1] = e = key(5)e = next = key(9) 结果如下图所示接着执行下一轮循环，结果状态图如下所示继续下一轮循环，结果状态图如下所示此时循环链表形成，并且key(11)无法加入到线程1的新数组。在下一次访问该链表时会出现死循环。 Fast-fail产生原因在使用迭代器的过程中如果HashMap被修改，那么ConcurrentModificationException将被抛出，也即Fast-fail策略。 当HashMap的iterator()方法被调用时，会构造并返回一个新的EntryIterator对象，并将EntryIterator的expectedModCount设置为HashMap的modCount（该变量记录了HashMap被修改的次数）。12345678HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125;&#125; 在通过该Iterator的next方法访问下一个Entry时，它会先检查自己的expectedModCount与HashMap的modCount是否相等，如果不相等，说明HashMap被修改，直接抛出ConcurrentModificationException。该Iterator的remove方法也会做类似的检查。该异常的抛出意在提醒用户及早意识到线程安全问题。 线程安全解决方案单线程条件下，为避免出现ConcurrentModificationException，需要保证只通过HashMap本身或者只通过Iterator去修改数据，不能在Iterator使用结束之前使用HashMap本身的方法修改数据。因为通过Iterator删除数据时，HashMap的modCount和Iterator的expectedModCount都会自增，不影响二者的相等性。如果是增加数据，只能通过HashMap本身的方法完成，此时如果要继续遍历数据，需要重新调用iterator()方法从而重新构造出一个新的Iterator，使得新Iterator的expectedModCount与更新后的HashMap的modCount相等。 多线程条件下，可使用Collections.synchronizedMap方法构造出一个同步Map，或者直接使用线程安全的ConcurrentHashMap。 Java 7基于分段锁的ConcurrentHashMap数据结构Java 7中的ConcurrentHashMap的底层数据结构仍然是数组和链表。与HashMap不同的是，ConcurrentHashMap最外层不是一个大的数组，而是一个Segment的数组。每个Segment包含一个与HashMap数据结构差不多的链表数组。整体数据结构如下图所示。 寻址方式在读写某个Key时，先取该Key的哈希值。并将哈希值的高N位对Segment个数取模从而得到该Key应该属于哪个Segment，接着如同操作HashMap一样操作这个Segment。为了保证不同的值均匀分布到不同的Segment，需要通过如下方法计算哈希值。12345678910111213private int hash(Object k) &#123; int h = hashSeed; if ((0 != h) &amp;&amp; (k instanceof String)) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16);&#125; 同样为了提高取模运算效率，通过如下计算，ssize即为大于concurrencyLevel的最小的2的N次方，同时segmentMask为2^N-1。这一点跟上文中计算数组长度的方法一致。对于某一个Key的哈希值，只需要向右移segmentShift位以取高sshift位，再与segmentMask取与操作即可得到它在Segment数组上的索引。12345678910int sshift = 0;int ssize = 1;while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1;&#125;this.segmentShift = 32 - sshift;this.segmentMask = ssize - 1;Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];&#125; 同步方式Segment继承自ReentrantLock，所以我们可以很方便的对每一个Segment上锁。 对于读操作，获取Key所在的Segment时，需要保证可见性(请参考如何保证多线程条件下的可见性)。具体实现上可以使用volatile关键字，也可使用锁。但使用锁开销太大，而使用volatile时每次写操作都会让所有CPU内缓存无效，也有一定开销。ConcurrentHashMap使用如下方法保证可见性，取得最新的Segment。1Segment&lt;K,V&gt; s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u) 获取Segment中的HashEntry时也使用了类似方法123HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile(tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE)&#125; 对于写操作，并不要求同时获取所有Segment的锁，因为那样相当于锁住了整个Map。它会先获取该Key-Value对所在的Segment的锁，获取成功后就可以像操作一个普通的HashMap一样操作该Segment，并保证该Segment的安全性。同时由于其它Segment的锁并未被获取，因此理论上可支持concurrencyLevel（等于Segment的个数）个线程安全的并发读写。 获取锁时，并不直接使用lock来获取，因为该方法获取锁失败时会挂起（参考可重入锁）。事实上，它使用了自旋锁，如果tryLock获取锁失败，说明锁被其它线程占用，此时通过循环再次以tryLock的方式申请锁。如果在循环过程中该Key所对应的链表头被修改，则重置retry次数。如果retry次数超过一定值，则使用lock方法申请锁。 这里使用自旋锁是因为自旋锁的效率比较高，但是它消耗CPU资源比较多，因此在自旋次数超过阈值时切换为互斥锁。 size操作put、remove和get操作只需要关心一个Segment，而size操作需要遍历所有的Segment才能算出整个Map的大小。一个简单的方案是，先锁住所有Sgment，计算完后再解锁。但这样做，在做size操作时，不仅无法对Map进行写操作，同时也无法进行读操作，不利于对Map的并行操作。 为更好支持并发操作，ConcurrentHashMap会在不上锁的前提逐个Segment计算3次size，如果某相邻两次计算获取的所有Segment的更新次数（每个Segment都与HashMap一样通过modCount跟踪自己的修改次数，Segment每修改一次其modCount加一）相等，说明这两次计算过程中无更新操作，则这两次计算出的总size相等，可直接作为最终结果返回。如果这三次计算过程中Map有更新，则对所有Segment加锁重新计算Size。该计算方法代码如下12345678910111213141516171819202122232425262728293031323334353637public int size() &#123; final Segment&lt;K,V&gt;[] segments = this.segments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn't retry try &#123; for (;;) &#123; if (retries++ == RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); // force creation &#125; sum = 0L; size = 0; overflow = false; for (int j = 0; j &lt; segments.length; ++j) &#123; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) &#123; sum += seg.modCount; int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; &#125; &#125; if (sum == last) break; last = sum; &#125; &#125; finally &#123; if (retries &gt; RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); &#125; &#125; return overflow ? Integer.MAX_VALUE : size;&#125; 不同之处ConcurrentHashMap与HashMap相比，有以下不同点 ConcurrentHashMap线程安全，而HashMap非线程安全 HashMap允许Key和Value为null，而ConcurrentHashMap不允许 HashMap不允许通过Iterator遍历的同时通过HashMap修改，而ConcurrentHashMap允许该行为，并且该更新对后续的遍历可见 Java 8基于CAS的ConcurrentHashMap注：本章的代码均基于JDK 1.8.0_111 数据结构Java 7为实现并行访问，引入了Segment这一结构，实现了分段锁，理论上最大并发度与Segment个数相等。Java 8为进一步提高并发性，摒弃了分段锁的方案，而是直接使用一个大的数组。同时为了提高哈希碰撞下的寻址性能，Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))）。其数据结构如下图所示 寻址方式Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。同样为了避免不太好的Key的hashCode设计，它通过如下方法计算得到Key的最终哈希值。不同的是，Java 8的ConcurrentHashMap作者认为引入红黑树后，即使哈希冲突比较严重，寻址效率也足够高，所以作者并未在哈希值的计算上做过多设计，只是将Key的hashCode值与其高16位作异或并保证最高位为0（从而保证最终结果为正整数）。123static final int spread(int h) &#123; return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125; 同步方式对于put操作，如果Key对应的数组元素为null，则通过CAS操作将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果该put操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。 对于读操作，由于数组被volatile关键字修饰，因此不用担心数组的可见性问题。同时每个元素是一个Node实例（Java 7中每个元素是一个HashEntry），它的Key值和hash值都由final修饰，不可变更，无须关心它们被修改后的可见性问题。而其Value及对下一个元素的引用由volatile修饰，可见性也有保障。123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next;&#125; 对于Key对应的数组元素的可见性，由Unsafe的getObjectVolatile方法保证。123static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125; size操作put方法和remove方法都会通过addCount方法维护Map的size。size方法通过sumCount获取由addCount方法维护的Map的size。 参考与感谢 郭俊 Jason : Java进阶（六）从ConcurrentHashMap的演进看Java多线程核心技术]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 LinkedHashMap 实现本地缓存]]></title>
    <url>%2F2018%2F08%2F14%2F2018-2018-08-14-%E5%9F%BA%E4%BA%8E-LinkedHashMap-%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[缓存缓存是一种提高应用程序性能的简单方法，应用程序从磁盘或数据库表中读取数据，但可能会多次重新读取相同的数据。大量的IO操作必然会导致应用程序性能降低，解决这个问题的简单办法就是，数据使用后一段时间内不丢弃，将其保存在内存中，以便减少不必要的IO操作。 LRU 缓存LRU (Least Recently Used)，即最久未使用算法。LRU 缓存就是选择最长时间未被使用的数据移除。 FIFO 缓存FIFO (First In First Out)，即先进先出算法。FIFO 缓存就是选择最先调入缓存数据进行替换。 基于 LinkedHashMap 的缓存对一个 Cache 来说最常用的操作有三种：插入 (insert)、替换 (replace)、查找(lookup)。同时缓存能够自动丢弃一段时间未访问的数据，以限制缓存空间的无限增长。java.util.LinkedHashMap 已经实现了顺序存储，默认情况下按照元素的添加顺序存储，也可以启用按照访问顺序存储，即最近读取的数据放在最前面，最早读取的数据放在最后面，同时它包括自动删除数据的方法（如下），该方法能够让我们不用关心缓存的清除。123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; LinkedHashMap 构造函数如下：1234public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; LinkedHashMap 元素大于 capacity * loadFactor 的时候，就会自动进行两倍扩容，为使缓存大小不会进行自动扩容，初始化大小（initialCapacity）设置为 (CACHE_SIZE / loadFactor) + 1。负载因子（loadFactor）选择默认值 0.75。当参数 accessOrder 为 true 时，即会按照访问顺序排序，最近访问的放在最前，最早访问的放在后面；当参数 accessOrder 为 false 时，即可实现先进先出。 下面是 LRU 缓存和 FIFO 缓存的实现方式，在公共方法上要加上 synchronized 关键字，防止线程同步问题：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.util.LinkedHashMap;import java.util.Map;import java.util.Set;/** * 原生 Java 本地 LRU、FIFO 缓存，LinkedHashMap 实现 * * @author Leaves * @version 1.0.0 * @date 2018/8/10 */public class LinkedHashMapCache&lt;K, V&gt; &#123; private final int CACHE_SIZE; private static final float LOAD_FACTORY = 0.75f; private LinkedHashMap&lt;K, V&gt; map; /** * @param cacheSize 缓存大小 * @param accessOrder true LRU, false FIFO */ public LinkedHashMapCache(int cacheSize, boolean accessOrder) &#123; CACHE_SIZE = cacheSize; //LinkedHashMap 元素大于 capacity * loadFactor 的时候，就会自动进行两倍扩容 //为使缓存大小不会进行自动扩容，初始化大小设置为 (CACHE_SIZE / loadFactor) + 1 int initialCapacity = (int) Math.ceil(CACHE_SIZE / LOAD_FACTORY) + 1; map = new LinkedHashMap&lt;K, V&gt;(initialCapacity, LOAD_FACTORY, accessOrder) &#123; @Override protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; CACHE_SIZE; &#125; &#125;; &#125; public synchronized void put(K key, V value) &#123; map.put(key, value); &#125; public synchronized V get(K key) &#123; return map.get(key); &#125; public synchronized void clear() &#123; map.clear(); &#125; public synchronized int size() &#123; return map.size(); &#125; public synchronized void remove(K key) &#123; map.remove(key); &#125; public synchronized Set&lt;Map.Entry&lt;K, V&gt;&gt; getAll() &#123; return map.entrySet(); &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123; stringBuilder.append(String.format("%s -&gt; %s\n", entry.getKey(), entry.getValue())); &#125; return stringBuilder.toString(); &#125; public static void main(String[] args) &#123; System.out.println("========== LRU =========="); Long start1 = System.currentTimeMillis(); LinkedHashMapCache&lt;Integer, String&gt; lru = new LinkedHashMapCache&lt;&gt;(5, true); lru.put(1, "1"); lru.put(2, "1"); lru.put(3, "1"); lru.put(4, "1"); lru.put(5, "1"); System.out.println(lru.toString()); lru.put(11, "2"); lru.get(2); lru.put(12, "3"); lru.get(4); System.out.println(lru.toString()); System.out.println(System.currentTimeMillis() - start1); System.out.println("========== FIFO =========="); Long start2 = System.currentTimeMillis(); LinkedHashMapCache&lt;Integer, String&gt; fifo = new LinkedHashMapCache&lt;&gt;(5, false); fifo.put(1, "1"); fifo.put(2, "1"); fifo.put(3, "1"); fifo.put(4, "1"); fifo.put(5, "1"); System.out.println(fifo.toString()); fifo.put(11, "2"); fifo.get(2); fifo.put(12, "3"); fifo.get(4); System.out.println(fifo.toString()); System.out.println(System.currentTimeMillis() - start2); &#125;&#125; 参考与感谢 Pete Ford : How to set up a simple LRU cache using LinkedHashMap]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Redis 实现可重入分布式锁]]></title>
    <url>%2F2018%2F08%2F08%2F2018-2018-08-08-%E5%9F%BA%E4%BA%8E-Redis-%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[分布式锁分布式锁是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。 SETNX key value Set key to hold string value if key does not exist. In that case, it is equal to SET. When key already holds a value, no operation is performed. SETNX is short for “SET if Not eXists”.Return valueInteger reply, specifically: 1 if the key was set 0 if the key was not set Examples1234567redis&gt; SETNX mykey "Hello"(integer) 1redis&gt; SETNX mykey "World"(integer) 0redis&gt; GET mykey"Hello"redis&gt; 以上是官方文档，意思简单说就是：如果 key 不存在，则 set 成功，如果 key 已经存在，则 set 失败。根据 SETNX 的这个特性，我们可以使用它实现分布式锁。 必须考虑的问题处理死锁当一个客户端获取锁成功之后，假如它崩溃了导致它再也无法和 Redis 节点通信，那么它就会一直持有这个锁，导致其它客户端永远无法获得锁了，因此锁必须要有一个自动释放的时间。通常我们会把获取锁的操作分成两个 Redis 命令：1234redis&gt; setnx LOCK 7978ff8a-170c-4422-ab17-6a5d846acd92(integer) 1redis&gt; expire LOCK 30(integer) 1 如果客户端在执行完 setnx LOCK 7978ff8a-170c-4422-ab17-6a5d846acd92 命令后由于某种原因，客户端宕机了，那么这时这把锁并没有过期时间，导致其它客户端永远无法获得锁了。因此对于锁的过期时间设置不能分为两步操作，Spring Boot 的 StringRedisTemplate 并没提供原子性操作，一条命令设置 key、value、expire，Redis 官方提供的 Jedis 客户端中的 JedisCommands 接口就可以实现这个操作，如下：1234567private boolean setNX(String key, String value, long expire) &#123; String result = stringRedisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt; &#123; JedisCommands commands = (JedisCommands) connection.getNativeConnection(); return commands.set(key, value, "NX", "PX", expire); &#125;); return "OK".equals(result);&#125; 锁被其他线程释放如果不加任何处理即简单使用 SETNX 实现 Redis 分布式锁，就会遇到一个问题：如果线程 C1 获得锁，但由于业务处理时间过长，锁在线程 C1 还未处理完业务之前已经过期了，这时线程 C2 获得锁，在线程 C2 处理业务期间线程 C1 完成业务执行释放锁操作，但这时线程 C2 仍在处理业务线程 C1 释放了线程 C2 的锁，导致线程 C2 业务处理实际上没有锁提供保护机制；同理线程 C2 可能释放线程 C3 的锁，从而导致严重的问题。 因此每个线程释放锁的时候只能释放自己的锁，即锁必须要有一个拥有者的标记，并且也需要保证释放锁的原子性操作。 锁拥有着的标志我们可以用 UUID 在实现，将其在获取锁的时候作为 value 值 set 到 Redis中。释放锁的时候先判断锁对应的 UUID 是否与线程中的 UUID 相同，相同时才做删除操作。 从 Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 EVAL 命令对 Lua 脚本进行求值，通过 Lua 脚本来达到释放锁的原子操作，脚本如下：12345if redis.call("get", KEYS[1]) == ARGV[1] then return redis.call("del", KEYS[1])else return 0end Spring Boot 可以通过 StringRedisTemplate 执行以下代码执行 Lua 脚本：123456789101112131415private boolean deleteKey(List&lt;String&gt; keys, List&lt;String&gt; args) &#123; Object result = stringRedisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; &#123; Object nativeConnection = connection.getNativeConnection(); // 单机模式 if (nativeConnection instanceof Jedis) &#123; return ((Jedis) nativeConnection).eval(LUA_UNLOCK_SCRIPT, keys, args); &#125; // 集群模式 else if (nativeConnection instanceof JedisCluster) &#123; return ((JedisCluster) nativeConnection).eval(LUA_UNLOCK_SCRIPT, keys, args); &#125; return 0L; &#125;); return result != null &amp;&amp; Long.parseLong(result.toString()) &gt; 0;&#125; 可重入锁可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，如果没有可重入锁的支持，在第二次尝试获得锁时将会进入死锁状态。ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。在这里，我们可以利用在 Redis 保存的 value 值进行判断，获得锁后我们将 UUID 存入 ThreadLocal 中，同一线程再次尝试获取锁的时候将 ThreadLocal 中的 UUID 与 Redis 的 value 比较，如果相同则表示这把锁所以该线程，即实现可重入锁。 分布式锁实现定义 Redis 分布式锁接口：123456789101112131415161718192021/** * Redis 分布式锁接口 * * @author Leaves * @version 1.0.0 * @date 2018/8/8 */public interface IRedisDistributedLock &#123; boolean lock(String key); boolean lock(String key, long waitMillis); boolean lock(String key, long waitMillis, long sleepMillis); boolean lock(String key, long expire, long waitMillis, long sleepMillis); boolean lock(String key, long expire, long waitMillis, long sleepMillis, int retries); boolean release(String key);&#125; RedisDistributedLockImpl 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219import com.lm.util.ApplicationContextUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.data.redis.core.RedisCallback;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Component;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisCluster;import redis.clients.jedis.JedisCommands;import java.util.ArrayList;import java.util.List;import java.util.UUID;/** * Redis 分布式锁 * * @author Leaves * @version 1.0.0 * @date 2018/8/8 */@Componentpublic class RedisDistributedLockImpl implements IRedisDistributedLock &#123; private final Logger logger = LoggerFactory.getLogger(RedisDistributedLockImpl.class); private StringRedisTemplate stringRedisTemplate = ApplicationContextUtil.getBean(StringRedisTemplate.class); /** * 锁前缀 */ private static final String ROOT_KEY = "LOCK_"; /** * 过期时间，ms */ private static final long EXPIRE = 15000L; /** * 最长等待时间，ms */ private static final long WAIT_MILLIS = 10000L; /** * 重试等待时间，ms */ private static final long SLEEP_MILLIS = 500L; /** * 最多重试次数 */ private static final int RETRIES = Integer.MAX_VALUE; /** * 使用 ThreadLocal 存储 key 的 value 值，防止同步问题 */ private ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); /** * 原子操作释放锁 Lua 脚本 */ private static final String LUA_UNLOCK_SCRIPT = "if redis.call(\"get\", KEYS[1]) == ARGV[1] " + "then " + "return redis.call(\"del\", KEYS[1]) " + "else " + "return 0 " + "end"; @Override public boolean lock(String key) &#123; return setLock(key, EXPIRE, WAIT_MILLIS, SLEEP_MILLIS, RETRIES); &#125; @Override public boolean lock(String key, long waitMillis) &#123; return setLock(key, EXPIRE, waitMillis, SLEEP_MILLIS, RETRIES); &#125; @Override public boolean lock(String key, long waitMillis, long sleepMillis) &#123; return setLock(key, EXPIRE, waitMillis, SLEEP_MILLIS, RETRIES); &#125; @Override public boolean lock(String key, long expire, long waitMillis, long sleepMillis) &#123; return setLock(key, expire, waitMillis, sleepMillis, RETRIES); &#125; @Override public boolean lock(String key, long expire, long waitMillis, long sleepMillis, int retries) &#123; return setLock(key, expire, waitMillis, sleepMillis, retries); &#125; /** * 获取 Redis 锁 * * @param key 锁名称 * @param expire 锁过期时间 * @param retries 最多重试次数 * @param sleepMillis 重试等待时间 * @param waitMillis 最长等待时间 * @return */ private boolean setLock(String key, long expire, long waitMillis, long sleepMillis, int retries) &#123; //检查 key 是否为空 if (key == null || "".equals(key)) &#123; return false; &#125; try &#123; long startTime = System.currentTimeMillis(); key = ROOT_KEY + key; //可重入锁判断 String v = threadLocal.get(); if (v != null &amp;&amp; isReentrantLock(key, v)) &#123; return true; &#125; //获取锁 String value = UUID.randomUUID().toString(); while (!this.setNX(key, value, expire)) &#123; //超过最大重试次数后获取锁失败 if (retries-- &lt; 1) &#123; return false; &#125; //等待下一次尝试 Thread.sleep(sleepMillis); //超过最长等待时间后获取锁失败 if (System.currentTimeMillis() - startTime &gt; waitMillis) &#123; return false; &#125; &#125; threadLocal.set(value); return true; &#125; catch (Exception e) &#123; logger.error("redis lock get: &#123;&#125;", e.getMessage()); return false; &#125; &#125; /** * SET if Not eXists */ private boolean setNX(String key, String value, long expire) &#123; String result = stringRedisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt; &#123; JedisCommands commands = (JedisCommands) connection.getNativeConnection(); return commands.set(key, value, "NX", "PX", expire); &#125;); return "OK".equals(result); &#125; /** * 可重入锁判断 */ private boolean isReentrantLock(String key, String v) &#123; ValueOperations kvValueOperations = stringRedisTemplate.opsForValue(); String value = (String) kvValueOperations.get(key); if (value == null) &#123; return false; &#125; return v.equals(value); &#125; /** * 释放锁 */ @Override public boolean release(String key) &#123; if (key == null || "".equals(key)) &#123; return false; &#125; List&lt;String&gt; keys = new ArrayList&lt;&gt;(1); keys.add(ROOT_KEY + key); List&lt;String&gt; args = new ArrayList&lt;&gt;(1); args.add(threadLocal.get()); threadLocal.remove(); try &#123; return deleteKey(keys, args); &#125; catch (Exception e) &#123; logger.error("redis lock release: &#123;&#125;", e.getMessage()); &#125; return false; &#125; /** * 删除 redis key * &lt;p&gt;集群模式和单机模式执行脚本方法一样，但没有共同的接口 * &lt;p&gt;使用lua脚本删除redis中匹配value的key，可以避免由于方法执行时间过长而 redis 锁自动过期失效的时候误删其他线程的锁 */ private boolean deleteKey(List&lt;String&gt; keys, List&lt;String&gt; args) &#123; Object result = stringRedisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; &#123; Object nativeConnection = connection.getNativeConnection(); // 单机模式 if (nativeConnection instanceof Jedis) &#123; return ((Jedis) nativeConnection).eval(LUA_UNLOCK_SCRIPT, keys, args); &#125; // 集群模式 else if (nativeConnection instanceof JedisCluster) &#123; return ((JedisCluster) nativeConnection).eval(LUA_UNLOCK_SCRIPT, keys, args); &#125; return 0L; &#125;); return result != null &amp;&amp; Long.parseLong(result.toString()) &gt; 0; &#125;&#125; 后记可以基于 AOP 定义 Redis 分布式锁注解，在方法级别上使用更加方便。 参考与感谢 Redis 官方文档：SETNX key value]]></content>
      <categories>
        <category>锁</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 国际化]]></title>
    <url>%2F2018%2F08%2F06%2F2018-2018-08-06-Spring-Boot-%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言在信息技术领域，国际化与本地化（英文：internationalization and localization）是指修改软件使之能适应目标市场的语言、地区差异以及技术需要。 国际化是指在设计软件，将软件与特定语言及地区脱钩的过程。当软件被移植到不同的语言及地区时，软件本身不用做内部工程上的改变或修正。本地化则是指当移植软件时，加上与特定区域设置有关的信息和翻译文件的过程。 国际化和本地化之间的区别虽然微妙，但却很重要。国际化意味着产品有适用于任何地方的“潜力”；本地化则是为了更适合于“特定”地方的使用，而另外增添的特色。用一项产品来说，国际化只需做一次，但本地化则要针对不同的区域各做一次。这两者之间是互补的，并且两者合起来才能让一个系统适用于各地。 基于他们的英文单字长度过长，常被分别简称成i18n（18意味着在“internationalization”这个单字中，i和n之间有18个字母）及L10n。使用大写的L以利区分i18n中的i和易于分辨小写l与1。 @国际化与本地化zh.wikipedia.org/wiki/国际化与本地化 定义国际化配置文件国际化配置文件 messages.properties（默认，当找不到语言的配置的时候，使用该文件语言进行展示） messages_en.properties（英语） messages_de.propertie（德语） messages_fr.properties（法语） messages_zh_TW.properties（中文-繁体） 将这些文件放到 classpath:resources/i18n 目录下即可，如图： 国际化配置文件内容messages.properties12ERROR=unknownSUCCESS=unknown messages_en.properties12ERROR=errorSUCCESS=success messages_de.properties12ERROR=FehlerSUCCESS=Erfolg messages_fr.properties12ERROR=ÉchecSUCCESS=Le succès messages_zh_TW.properties12ERROR=失敗（繁體）SUCCESS=成功（繁體） Spring Boot 配置定义一个区域解析器，在应用程序上下文中注册一个 LocaleResolver 类型的区域解析器 Bean，Bean的名称设置为 localeResolver，这样 DispatcherServlet 才能自动侦测到它。 方法一添加 I18nConfiguration 配置类，使用 Accept-Language Header 区域解析器特点：配置简单，使用方便，推荐使用 1234567891011121314151617181920212223242526272829303132333435/** * 国际化配置 * * @author Leaves * @version 1.0.0 * @date 2018/8/6 */@Configurationpublic class I18nConfiguration &#123; /** * Accept-Language Header 区域解析器 */ @Bean(value = "localeResolver") public LocaleResolver acceptHeaderLocaleResolver() &#123; AcceptHeaderLocaleResolver acceptHeaderLocaleResolver = new AcceptHeaderLocaleResolver(); acceptHeaderLocaleResolver.setDefaultLocale(Locale.US); return acceptHeaderLocaleResolver; &#125; /** * 加载国际化配置文件资源 */ @Bean public ReloadableResourceBundleMessageSource messageSource() &#123; ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); //设置国际化配置文件存放目录 messageSource.setBasename("classpath:i18n/messages"); //设置加载资源的缓存失效时间，-1表示永久有效，默认为-1 messageSource.setCacheSeconds(-1); //设定 Resource Bundle 编码方式，默认为UTF-8 messageSource.setDefaultEncoding("UTF-8"); return messageSource; &#125;&#125; 方法二使用 SessionLocaleResolver 或 CookieLocaleResolver 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 国际化配置 * * @author Leaves * @version 1.0.0 * @date 2018/8/6 */@Configurationpublic class I18nConfiguration extends WebMvcConfigurerAdapter &#123; /** * Session 区域解析器 */ @Bean(value = "localeResolver") public LocaleResolver sessionLocaleResolver() &#123; SessionLocaleResolver sessionLocaleResolver = new SessionLocaleResolver(); sessionLocaleResolver.setDefaultLocale(Locale.US); return sessionLocaleResolver; &#125; /** * 注册 LocaleChangeInterceptor 拦截器，并将其引用到任何需要支持多种语言的处理器映射 */ private LocaleChangeInterceptor localeChangeInterceptor() &#123; LocaleChangeInterceptor localeChangeInterceptor = new LocaleChangeInterceptor(); localeChangeInterceptor.setParamName("locale"); return localeChangeInterceptor; &#125; /** * LocaleChangeInterceptor 拦截器注册 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(localeChangeInterceptor()); &#125; /** * 加载国际化配置文件资源 */ @Bean public ReloadableResourceBundleMessageSource messageSource() &#123; ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); //设置国际化配置文件存放目录 messageSource.setBasename("classpath:i18n/messages"); //设置加载资源的缓存失效时间，-1表示永久有效，默认为-1 messageSource.setCacheSeconds(-1); //设定 Resource Bundle 编码方式，默认为UTF-8 messageSource.setDefaultEncoding("UTF-8"); return messageSource; &#125;&#125; 国际化使用Spring Boot 通过以上两步就完成了国际化配置，那怎么使用呢？首先定义一个测试接口123456789@Autowiredprivate MessageSource messageSource;@RequestMapping(value = "/test", method = RequestMethod.GET)public String languageTest(@RequestParam(value = "result", required = false) String result) &#123; Locale locale = LocaleContextHolder.getLocale(); logger.info(locale.toString()); return messageSource.getMessage(result == null ? "SUCCESS" : result, null, "unknown", locale);&#125; LocaleContextHolder.getLocale() 是获取语言的关键方法，通过 MessageSource 的 String getMessage(String var1, Object[] var2, String var3, Locale var4) 接口获取国际化配置文件（messages_xx.properties）中的不同语言内容。 测试接下来我将使用 Postman 工具来进行测试设置语言的关键在于 HTTP Header 上加上 Accept-Language 参数 下面是两个国际化方法的几种语言测试结果： 方法一测试结果 方法二测试结果 到这里，Spring Boot 的国际化就完成了~~ 区域解析器AcceptHeaderLocaleResolverSpring 采用的默认区域解析器是 AcceptHeaderLocaleResolver。它通过检验 HTTP 请求的 Accept-Language 头部来解析区域。这个头部是由用户的 Web 浏览器根据底层操作系统的区域设置进行设定或者 Web 端设定。 SessionLocaleResolverSession 区域解析器，会从用户请求相关的 Session 中获取本地化信息。如果不存在，它会根据 Accept-Language 头部确定默认区域，只针对当前的会话有效，Session 失效，还原为默认状态。 CookieLocaleResolverCookie 区域解析器，检查客户端中的 Cookie 是否包含本地化信息，如果有的话就使用。当配置这个解析器的时候，可以指定 Cookie 名，以及 Cookie 的最长生存期。 FixedLocaleResolver固定区域解析器，一直使用固定的 Local, 改变 Local 是不支持的，一旦程序启动时设定，则无法改变 Local。 通过 url 中的参数修改语言除了显式调用 LocaleResolver.setLocale() 来修改用户的区域之外，还可以将 LocaleChangeInterceptor 拦截器应用到处理程序映射中（如方法二），它会发现当前 HTTP 请求中出现的特殊参数。其中的参数名称可以通过拦截器的 paramName (默认值 locale) 属性进行自定义。如果这种参数出现在当前请求中，拦截器就会根据参数值来改变区域。注：LocaleChangeInterceptor 可以和 SessionLocaleResolver、CookieLocaleResolver 一起使用，但不能和FixedLocaleResolver 一起使用，否则会抛出异常信息。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[断点续传下载文件，多媒体在线播放]]></title>
    <url>%2F2018%2F07%2F31%2F2018-2018-07-31-%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6-%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9C%A8%E7%BA%BF%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[断点续传断点续传是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度。 关键点所谓断点续传，也就是要从文件已经下载的地方开始继续下载。客户端在 HTTP 请求中体现在： Range: bytes=17563648- 服务器收到这个请求以后，返回的信息如下： Accept-Ranges: bytesContent-Range: bytes 17563648-36057953/36057954Content-Length: 18494306 HTTP 响应码应变为 206，如下所示： 实现，以 Spring Boot 1.5.14.RELEASE 为例实现方法如下，关键点在于 HTTP 响应头设置，其他注意点已在注释中说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 文件下载，断点续传 * * @param request * @param response * @param fileName * @return */public boolean download(HttpServletRequest request, HttpServletResponse response, String fileName) &#123; //文件目录 Calendar calendar = Calendar.getInstance(); File serverDir = new File(System.getProperty("user.dir") + File.separator + "uploads" + File.separator + calendar.get(Calendar.YEAR) + File.separator + (calendar.get(Calendar.MONTH) + 1)); File file = new File(serverDir + File.separator + fileName); //下载开始位置 long startByte = 0; //下载结束位置 long endByte = file.length() - 1; //获取下载范围 String range = request.getHeader("range"); if (range != null &amp;&amp; range.contains("bytes=") &amp;&amp; range.contains("-")) &#123; range = range.substring(range.lastIndexOf("=") + 1).trim(); String rangeArray[] = range.split("-"); if (rangeArray.length == 1) &#123; //Example: bytes=1024- if (range.endsWith("-")) &#123; startByte = Long.parseLong(rangeArray[0]); &#125; else &#123; //Example: bytes=-1024 endByte = Long.parseLong(rangeArray[0]); &#125; &#125; //Example: bytes=2048-4096 else if (rangeArray.length == 2) &#123; startByte = Long.parseLong(rangeArray[0]); endByte = Long.parseLong(rangeArray[1]); &#125; &#125; long contentLength = endByte - startByte + 1; String contentType = request.getServletContext().getMimeType(fileName); //HTTP 响应头设置 //断点续传，HTTP 状态码必须为 206，否则不设置，如果非断点续传设置 206 状态码，则浏览器无法下载 if (range != null) &#123; response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT); &#125; response.setContentType(contentType); response.setHeader("Content-Type", contentType); response.setHeader("Content-Length", String.valueOf(contentLength)); response.setHeader("Accept-Ranges", "bytes"); //Content-Range: 下载开始位置-下载结束位置/文件大小 response.setHeader("Content-Range", "bytes " + startByte + "-" + endByte + "/" + file.length()); //Content-disposition: inline; filename=xxx.xxx 表示浏览器内嵌显示该文件 //Content-disposition: attachment; filename=xxx.xxx 表示浏览器下载该文件 response.setHeader("Content-Disposition", "inline; filename=" + fileName); //传输文件流 BufferedOutputStream outputStream = null; RandomAccessFile randomAccessFile = null; //已传送数据大小 long transmittedLength = 0; try &#123; //以只读模式设置文件指针偏移量 randomAccessFile = new RandomAccessFile(file, "r"); randomAccessFile.seek(startByte); outputStream = new BufferedOutputStream(response.getOutputStream()); byte[] buff = new byte[4096]; int len; while (transmittedLength &lt; contentLength &amp;&amp; (len = randomAccessFile.read(buff)) != -1) &#123; outputStream.write(buff, 0, len); transmittedLength += len; &#125; outputStream.flush(); response.flushBuffer(); logger.info("下载完毕: &#123;&#125;-&#123;&#125;: &#123;&#125;", startByte, endByte, transmittedLength); return true; &#125; catch (IOException e) &#123; logger.info("下载停止: &#123;&#125;-&#123;&#125;: &#123;&#125;", startByte, endByte, transmittedLength); &#125; finally &#123; try &#123; if (randomAccessFile != null) &#123; randomAccessFile.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return false;&#125; 多媒体播放实现断点续传是多媒体播放的关键点 HTML 示例1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Video&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;video src="http://127.0.0.1:8001/demo/download/o_1cjkl6f5o1lslun02dv1mn3nup2n.mp4" controls="controls"&gt; Your browser does not support the video tag.&lt;/video&gt;&lt;br/&gt;&lt;embed src="http://27.0.0.1:8001/demo/download/%E5%A6%82%E6%AD%8C.mp3"/&gt;&lt;/body&gt;&lt;/html&gt; 效果图 参考与感谢 钟华 : 用 Java 实现断点续传 (HTTP)]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>断点续传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plupload 文件断点续传，文件分块上传]]></title>
    <url>%2F2018%2F07%2F30%2F2018-2018-07-30-Plupload-%E6%96%87%E4%BB%B6%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0-%E6%96%87%E4%BB%B6%E5%88%86%E5%9D%97%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[Plupload 介绍Plupload 是一款由著名的 Web 编辑器 TinyMCE 团队开发的上传组件，简单易用且功能强大。Plupload 会自动侦测当前的浏览器环境，选择最合适的上传方式，并且会优先使用 HTML5 的方式。该前端插件实现原理简单来说就是将文件按照指定分块大小切割成 n 块，然后依次将这 n 块文件数据上传至服务端，可实现暂停、继续上传。这也算是断点续传的一种实现方式。 本人在使用过程中对于这个插件也遇到了一些坑，比如，上传暂停后重新开始，Plupload 会重复上传上次最后一块文件块；该问题的原因在于调用 Plupload 的 stop() 方法后 Plupload 会立刻中断本次请求，这时服务器正在处理请求，还未及时将处理结果返回至前端请求被中断了，造成服务器实际已保存该文件块，但 Plupload 认为该文件块未上传完成，导致暂停后重新开始，服务端文件块重复，服务端接收到的文件与实际不同。在本文中我将会解决这个问题。 Plupload 获取正确的途径当然要从官网下载本人下载版本 Plupload 2.3.6 AGPLv3，里面包含需要用到的 js，还有 Custom example 和 Events example 两个 Demo 页面。接下来将改写 Custom example 页面，实现需要的功能。 前端 HTML 页面前端使用比较简单，通过一些简单参数配置即可使用，具体参数设置可查看官方文档，其中主要用到 Plupload 插件的 start() 和 stop() 两个方法 修改后的 Custom example 如下，附上源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" dir="ltr"&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"/&gt; &lt;title&gt;Plupload - Custom example&lt;/title&gt; &lt;!-- production --&gt; &lt;script type="text/javascript" src="../js/plupload.full.min.js"&gt;&lt;/script&gt; &lt;!-- debug &lt;script type="text/javascript" src="../js/moxie.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/plupload.dev.js"&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body style="font: 13px Verdana; background: #eee; color: #333"&gt;&lt;h1&gt;Custom example&lt;/h1&gt;&lt;p&gt;Shows you how to use the core plupload API.&lt;/p&gt;&lt;div id="filelist"&gt;Your browser doesn't have Flash, Silverlight or HTML5 support.&lt;/div&gt;&lt;br/&gt;&lt;div id="container"&gt; &lt;a id="pickfiles" href="javascript:;"&gt;[Select files]&lt;/a&gt; &lt;a id="start" href="javascript:;"&gt;[Upload Start]&lt;/a&gt; &lt;a id="stop" href="javascript:;"&gt;[Upload Pause]&lt;/a&gt;&lt;/div&gt;&lt;br/&gt;&lt;pre id="console"&gt;&lt;/pre&gt;&lt;script type="text/javascript"&gt; // Custom example logic var uploader = new plupload.Uploader(&#123; runtimes: 'html5,flash,silverlight,html4', browse_button: 'pickfiles', // you can pass an id... container: document.getElementById('container'), // ... or DOM Element itself url: 'http://127.0.0.1:8001/demo/upload', //服务器端上传处理程序的URL flash_swf_url: '../js/Moxie.swf', silverlight_xap_url: '../js/Moxie.xap', chunk_size: '2mb', //分块大小 unique_names: true, //生成唯一文件名 send_file_name: true, //发送文件名 max_retries: 3, //在触发Error事件之前重试块或文件的次数 // multipart_params: &#123; gmtCreate : new Date().getTime() &#125;, //每次上传文件时要发送的键/值对的哈希值 filters: &#123; max_file_size: '4096mb', mime_types: [ // &#123;title : "Image files", extensions : "jpg,gif,png"&#125;, // &#123;title : "Zip files", extensions : "zip"&#125;, // &#123;title : "Video files", extensions : "mp4"&#125; &#123;title: "All files", extensions: "*"&#125; ] &#125;, init: &#123; PostInit: function () &#123; // uploader.setOption('multipart_params', &#123;gmtCreate: new Date().getTime()&#125;); document.getElementById('filelist').innerHTML = ''; document.getElementById('start').onclick = function () &#123; uploader.start(); return false; &#125;; document.getElementById('stop').onclick = function () &#123; uploader.stop(); return false; &#125;; &#125;, FilesAdded: function (up, files) &#123; plupload.each(files, function (file) &#123; document.getElementById('filelist').innerHTML += '&lt;div id="' + file.id + '"&gt;' + file.name + ' (' + plupload.formatSize(file.size) + ') &lt;b&gt;&lt;/b&gt;&lt;/div&gt;'; &#125;); &#125;, UploadProgress: function (up, file) &#123; document.getElementById(file.id).getElementsByTagName('b')[0].innerHTML = '&lt;span&gt;' + file.percent + "%&lt;/span&gt;"; &#125;, ChunkUploaded: function (up, file, info) &#123; // Called when file chunk has finished uploading console.log('[ChunkUploaded] File:', file, "Info:", info); &#125;, Error: function (up, err) &#123; document.getElementById('console').appendChild(document.createTextNode("\nError #" + err.code + ": " + err.message)); &#125; &#125; &#125;); uploader.init();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务端，以 Spring Boot 1.5.14.RELEASE 为例Plupload 对象Plupload 上传文件时会附带 name, chunks, chunk 三个参数，这里我通过 Plupload 对象接收参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Plupload 实体类，建议不要修改 * * @author Leaves * @version 1.0.0 * @date 2018/7/26 */public class Plupload &#123; /** * 文件名 */ private String name; /** * 上传文件总块数 */ private int chunks = -1; /** * 当前块数，从0开始计数 */ private int chunk = -1; /** * 上传时间戳，自定义 */ private Long gmtCreate; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getChunks() &#123; return chunks; &#125; public void setChunks(int chunks) &#123; this.chunks = chunks; &#125; public int getChunk() &#123; return chunk; &#125; public void setChunk(int chunk) &#123; this.chunk = chunk; &#125; public Long getGmtCreate() &#123; return gmtCreate; &#125; public void setGmtCreate(Long gmtCreate) &#123; this.gmtCreate = gmtCreate; &#125; @Override public String toString() &#123; return "Plupload&#123;" + "name='" + name + '\'' + ", chunks=" + chunks + ", chunk=" + chunk + ", gmtCreate=" + gmtCreate + '&#125;'; &#125;&#125; upload()，接收 Plupload 上传数据本文提到上传暂停后重新开始，Plupload 会重复上传上次最后一块文件数据这一问题，这里给出一种解决办法：每次收到 Plupload 上传的文件块，处理成功后将当前文件块编号记录到缓存（缓存需要设置过期时间，防止永久驻留），暂停后重新开始，服务端比较本次上传文件块是否已在上次上传处理，如果已处理则抛弃改文件块。 如果需要支持文件秒传，可以通过验证文件 MD5 值简单实现，Java 可通过 commons-codec 包下的 DigestUtils.md5Hex(new FileInputStream(filePath))); 方法获取文件 MD5 值，该 Demo 未做文件秒传。 具体实现，请看源码： /** * 文件上传，断点续传，分块上传 * * @param request * @param response * @param plupload * @return */ public boolean upload(HttpServletRequest request, HttpServletResponse response, Plupload plupload) { //按日期文件夹保存 Calendar calendar = Calendar.getInstance(); File serverDir = new File(System.getProperty("user.dir") + File.separator + "uploads" + File.separator + calendar.get(Calendar.YEAR) + File.separator + (calendar.get(Calendar.MONTH) + 1)); //mkdirs() 可创建多级目录，mkdir() 只能创建一级目录 if (!serverDir.exists()) { if (serverDir.mkdirs()) { //文件夹创建失败返回403 response.setStatus(HttpServletResponse.SC_FORBIDDEN); return false; } } //文件名 String fileName = plupload.getName(); //上传文件总块数 int chunks = plupload.getChunks(); //当前上传块，从 0 开始 int nowChunk = plupload.getChunk(); //文件块重复检查 ValueOperations operations = redisTemplate.opsForValue(); Object lastChunk = operations.get("UPLOAD_" + plupload.getName()); if (lastChunk != null) { if (Objects.equals(Integer.parseInt(lastChunk.toString()), nowChunk)) { logger.warn("文件块重复，chunks: {}, now chunk: {}, last chunk: {}", chunks, nowChunk, lastChunk); return true; } } //获取文件 MultipartHttpServletRequest multipartHttpServletRequest = (MultipartHttpServletRequest) request; MultiValueMap&lt;String, MultipartFile&gt; map = multipartHttpServletRequest.getMultiFileMap(); if (map == null || map.size() &lt;= 0) { response.setStatus(HttpServletResponse.SC_FORBIDDEN); return false; } for (String key : map.keySet()) { List&lt;MultipartFile&gt; multipartFileList = map.get(key); File targetFile = new File(serverDir + File.separator + fileName); for (MultipartFile multipartFile : multipartFileList) { try { //上传文件总块数 &gt; 1，则为分块上传，需要进行合并 if (chunks &gt; 1) { this.writePartFile(multipartFile.getInputStream(), targetFile, nowChunk != 0); } else { //上传文件总块数 = 1，直接拷贝文件内容 multipartFile.transferTo(targetFile); } } catch (IOException e) { logger.error(e.getMessage()); e.printStackTrace(); response.setStatus(HttpServletResponse.SC_FORBIDDEN); return false; } } } //记录上传块数 if (nowChunk == chunks - 1) { redisTemplate.delete("UPLOAD_" + plupload.getName()); } else { operations.set("UPLOAD_" + plupload.getName(), String.valueOf(nowChunk), 86400L, TimeUnit.SECONDS); } return true; } /** * 分块写入 * * @param inputStream * @param file * @param append */ private void writePartFile(InputStream inputStream, File file, boolean append) { OutputStream outputStream = null; try { if (!append) { //从头开始写 outputStream = new BufferedOutputStream(new FileOutputStream(file)); } else { //追加写入 outputStream = new BufferedOutputStream(new FileOutputStream(file, true)); } byte[] bytes = new byte[1024]; int len = 0; while ((len = (inputStream.read(bytes))) &gt; 0) { outputStream.write(bytes, 0, len); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (outputStream != null) { outputStream.flush(); outputStream.close(); } if (inputStream != null) { inputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } 断点续传效果图]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>断点续传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装 Redis]]></title>
    <url>%2F2018%2F07%2F25%2F2018-2018-07-25-Linux-%E5%AE%89%E8%A3%85-Redis%2F</url>
    <content type="text"><![CDATA[以 Redis 4.0.10 为例Redis 官方下载地址 下载、解压、编译下载 wget http://download.redis.io/releases/redis-4.0.10.tar.gz 解压 tar xzf redis-4.0.10.tar.gz 编译 cd redis-4.0.10make 启动 Redis前台启动 src/redis-server 测试 Redis 是否启动 src/redis-cli 如果输出以下内容，表示 Redis 已启动 127.0.0.1:6379&gt; set foo barOK127.0.0.1:6379&gt; get foo“bar” 后台启动修改 Redis 配置文件 redis.conf vi redis.conf 123***daemonize yes*** 开启外网访问确保 redis.conf 中 daemonize 为 yes，确保守护进程开启，Redis 可以在后台可以运行 把 Redis 端口放到防火墙计划中 /sbin/iptables -I INPUT -p tcp –dport 6379 -j ACCEPT 修改 Redis 配置文件 redis.conf vi redis.conf 12345***# bind 127.0.0.1***protected-mode no*** 重启 Redis，并指定配置文件 src/redis-cli shutdownsrc/redis-server ./redis.conf 设置 Redis 开机启动在 /etc 下新建 redis 文件夹 mkdir /etc/redis 把安装 Redis 根目录里面的 redis.conf 复制到 /etc/redis/6379.conf cp redis.conf /etc/redis/6379.conf 复制 Redis 启动脚本Redis 启动脚本一般在 Redis 根目录的 utils 目录下，如果不知道路径，可以先查看路径 find / -name redis_init_script 复制启动脚本到 /etc/init.d/redis 文件中 cp utils/redis_init_script /etc/init.d/redis 修改启动脚本参数 vi /etc/init.d/redis 指定 Redis 安装路径EXEC=…CLIEXEC=…123456789101112131415161718192021#!/bin/sh## Simple Redis init.d script conceived to work on Linux systems# as it does use of the /proc filesystem.### BEGIN INIT INFO# Provides: redis_6379# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Redis data structure server# Description: Redis data structure server. See https://redis.io### END INIT INFOREDISPORT=6379EXEC=/usr/local/redis-4.0.10/src/redis-serverCLIEXEC=/usr/local/redis-4.0.10/src/redis-cliPIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pidCONF=&quot;/etc/redis/$&#123;REDISPORT&#125;.conf&quot;*** 关闭 Redis service redis stop 设为开机启动 chkconfig redis on 设为开机关闭 chkconfig redis off 启动 Redis service redis start 检查自启动项列表中没有 redis 这个 chkconfig –list redis 错误处理如果执行 make 报错，可能缺少某些依赖包 错误112345678910cd src &amp;&amp; make allmake[1]: 进入目录“/usr/local/redis-4.0.10/src” CC Makefile.depmake[1]: 离开目录“/usr/local/redis-4.0.10/src”make[1]: 进入目录“/usr/local/redis-4.0.10/src” CC adlist.o/bin/sh: cc: 未找到命令make[1]: *** [adlist.o] 错误 127make[1]: 离开目录“/usr/local/redis-4.0.10/src”make: *** [all] 错误 2 以上报错缺少 GCC，则如下命令安装： yum install gcc 错误21234567891011cd src &amp;&amp; make allmake[1]: 进入目录“/usr/local/redis-4.0.10/src” CC adlist.oIn file included from adlist.c:34:0:zmalloc.h:50:31: 致命错误：jemalloc/jemalloc.h：没有那个文件或目录 #include &lt;jemalloc/jemalloc.h&gt; ^编译中断。make[1]: *** [adlist.o] 错误 1make[1]: 离开目录“/usr/local/redis-4.0.10/src”make: *** [all] 错误 2 以上报错则如下命令解决： make MALLOC=libc]]></content>
      <categories>
        <category>基础服务</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装 MySQL 5.7]]></title>
    <url>%2F2018%2F07%2F18%2F2018-2018-07-18-Linux-%E5%AE%89%E8%A3%85-MySQL-5-7%2F</url>
    <content type="text"><![CDATA[MySQL 5.7.22 官方下载地址 清理 MySQL、下载解压清理 find / -name mysql | xargs rm -rf 下载 wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz 解压 tar -zxvf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz 重命名 mv mysql-5.7.22-linux-glibc2.12-x86_64 mysql 创建 MySQL 组、用户查看有没有mysql组 cat /etc/group | grep mysql 查看有没有mysql用户 cat /etc/passwd |grep mysql 没有则创建 groupadd mysqluseradd -r -g mysql mysql 更改 mysql 目录下所有的目录及文件夹所属组合用户 chown -R mysql mysqlchgrp -R mysql mysqlcd mysqlls -l123456789drwxr-xr-x. 2 mysql mysql 4096 7月 18 15:04 bin-rw-r--r--. 1 mysql mysql 17987 3月 4 21:40 COPYINGdrwxr-xr-x. 2 mysql mysql 52 7月 18 15:04 docsdrwxr-xr-x. 3 mysql mysql 4096 7月 18 15:04 includedrwxr-xr-x. 5 mysql mysql 4096 7月 18 15:04 libdrwxr-xr-x. 4 mysql mysql 28 7月 18 15:04 man-rw-r--r--. 1 mysql mysql 2478 3月 4 21:40 READMEdrwxr-xr-x. 28 mysql mysql 4096 7月 18 15:04 sharedrwxr-xr-x. 2 mysql mysql 86 7月 18 15:08 support-files 修改 my.cnf 配置文件从 5.7.18 开始不在二进制包中提供 my-default.cnf 文件 vi /etc/my.cnf my-default.cnf12345678910111213141516171819202122232425262728293031# For advice on how to change settings please see# # *** DO NOT EDIT THIS FILE. It‘s a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL.[mysqld]# Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M# Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin# These are commonly set, remove the # and set as required.# basedir = .....# datadir = .....# port = .....# server_id = .....# socket = .....# Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2M sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES my.cnf12345678910111213141516171819202122232425262728293031323334353637383940# For advice on how to change settings please see# # *** DO NOT EDIT THIS FILE. It‘s a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL.[client]default-character-set = utf8[mysql]default-character-set = utf8socket = /var/lib/mysql/mysql.sock[mysqld]character-set-server = utf8# Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M# Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin# These are commonly set, remove the # and set as required.basedir = /usr/local/mysql/datadir = /usr/local/mysql/data/port = 3306#server_id = socket = /var/lib/mysql/mysql.sock# Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mmax_connections = 1000sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 初始化 MySQL 数据库初始化 cd /usr/local/mysql./bin/mysqld –user=mysql –basedir=/usr/local/mysql –datadir=/usr/local/mysql/data –initialize 输出如下：123456782018-07-18T07:06:49.223422Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2018-07-18T07:06:49.223579Z 0 [Warning] &apos;NO_ZERO_DATE&apos;, &apos;NO_ZERO_IN_DATE&apos; and &apos;ERROR_FOR_DIVISION_BY_ZERO&apos; sql modes should be used with strict mode. They will be merged with strict mode in a future release.2018-07-18T07:06:49.223591Z 0 [Warning] &apos;NO_AUTO_CREATE_USER&apos; sql mode was not set.2018-07-18T07:06:50.630648Z 0 [Warning] InnoDB: New log files created, LSN=457902018-07-18T07:06:51.000475Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.2018-07-18T07:06:51.028751Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 24e198b5-8a59-11e8-9a33-aeceb5cf96b1.2018-07-18T07:06:51.031122Z 0 [Warning] Gtid table is not ready to be used. Table &apos;mysql.gtid_executed&apos; cannot be opened.2018-07-18T07:06:51.045661Z 1 [Note] A temporary password is generated for root@localhost: Ra%p1C(&gt;7J(p 添加 RSA Key cd /usr/local/mysqlbin/mysql_ssl_rsa_setup –datadir=/usr/local/mysql/data123456789101112131415Generating a 2048 bit RSA private key..+++.......................................................+++writing new private key to &apos;ca-key.pem&apos;-----Generating a 2048 bit RSA private key....................................................................+++...........................................................+++writing new private key to &apos;server-key.pem&apos;-----Generating a 2048 bit RSA private key..............................................................................................................................................+++..................................+++writing new private key to &apos;client-key.pem&apos;----- 编辑 /usr/local/mysql/support-files/mysql.server 文件 vi /usr/local/mysql/support-files/mysql.server1234...修改 basedir = /usr/local/mysql/修改 datadir = /usr/local/mysql/data/... 启动 MySQL 服务 cd /usr/local/mysql./support-files/mysql.server start 注意：如果遇到以下问题，执行以下操作Starting MySQL.Logging to ‘/usr/local/mysql/data/localhost.localdomain.err’.2018-07-18T07:08:26.909710Z mysqld_safe Directory ‘/var/lib/mysql’ for UNIX socket file don’t exists. mkdir /var/lib/mysqlchown mysql:mysql /var/lib/mysqlcd /usr/local/mysql./support-files/mysql.server start Starting MySQL… SUCCESS! ./support-files/mysql.server stop Shutting down MySQL… SUCCESS! ./support-files/mysql.server restart Shutting down MySQL… SUCCESS!Starting MySQL… SUCCESS! 修改 Root 密码，开启远程访问 cd /usr/local/mysql./bin/mysqld_safe –skip-grant-tables –skip-networking&amp; 登陆 cd /usr/local/mysql/bin./mysql -uroot -p 修改密码、授权远程登陆 mysql&gt;set password=password(“123456”);use mysql;update user set host=’%’ where user=’root’;GRANT ALL PRIVILEGES ON . TO ‘myuser‘@’%’ IDENTIFIED BY ‘mypwd’ WITH GRANT OPTION;FLUSH PRIVILEGES;exit; 重启 MySQL 服务 service mysql restart; 查看编码 show variables like ‘character%’; 配置 MySQL 服务开机自动启动拷贝启动文件到 /etc/init.d/ 下并重命令为 mysqld cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld 增加执行权限 chmod 755 /etc/init.d/mysqld 检查自启动项列表中没有 mysqld 这个，如果没有就添加 mysqld chkconfig –list mysqldchkconfig –add mysqld 设置MySQL在345等级自动启动 chkconfig –level 345 mysqld on 或用这个命令设置开机启动: chkconfig mysqld on MySQL 服务的启动/重启/停止启动 MySQL 服务 service mysqld start 停止 MySQL 服务 service mysqld stop 重启 MySQL 服务 service mysqld restart]]></content>
      <categories>
        <category>基础服务</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 安装 MySQL 5.7]]></title>
    <url>%2F2018%2F04%2F24%2F2018-2018-04-24-Windows-%E5%AE%89%E8%A3%85-MySQL-5-7%2F</url>
    <content type="text"><![CDATA[MySQL 5.7.xx ZIP版本配置方案MySQL 5.7.22 官方下载地址MySQL 官方配置参数查询 一、下载 MySQL 5.7.xx zip 安装包本机以 Windows10 64 位系统为例进入 Oracel 官网，选择 MySQL Windows (x86, 64-bit), ZIP Archive 下载包点此下载 二、解压安装包将MySQL数据库解压至目录 D:\Program Files\MySQL\mysql-5.7.xx-winx64将 D:\Program Files\MySQL\mysql-5.7.xx-winx64\bin 添加至环境变量 Path 中 三、创建一个空文件夹，命名为“data”，用来存放数据本机创建在 D:\Program Files\MySQL\mysql-5.7.xx-winx64 目录下，所以最后会看到D:\Program Files\MySQL\mysql-5.7.xx-winx64\data，此文件夹后面会有用到 四、配置启动配置文件把 D:\Program Files\MySQL\mysql-5.7.xx-winx64\my-default.ini 文件复制一份，重新命名为 my.ini，修改里面的几个参数， 配置文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html# *** DO NOT EDIT THIS FILE. It&apos;s a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL.[client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]character-set-server=utf8# Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M# Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin# These are commonly set, remove the # and set as required.# server_id = .....# MySQL 安装目录basedir = D:\Program Files\MySQL\mysql-5.7.22-winx64# MySQL 数据库数据存放目录datadir = D:\Program Files\MySQL\mysql-5.7.22-winx64\data# MySQL 端口port = 3306# 允许最大连接数，默认200max_connections=200# Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Msql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# explicit_defaults_for_timestamp=true 五、初始化数据目录 管理员身份打开 CMD; 当前路径定位到 D:\Program Files\MySQL\mysql-5.7.xx-winx64\bin 按照mysql官方文档给出的步骤还有一步 Selecting a MySQL Server Type，就是选择用 mysqld 还是 mysqld-debug. 一般使用如下命令： mysqld –defaults-file=”D:\Program Files\MySQL\mysql-5.7.xx-winx64\my.ini” –initialize-insecure 注： 这个命令很重要，它会初始化 data 目录，在执行此命令前请先把 data 目录下的所有文件先删除，否则会失败； 可以选择用 –initialize-insecure 或者 –initialize 来初始化，–initialize-insecure 初始化 root 密码为空，如果用 –initialize 来初始化，会产生一个随机密码； 执行成功后你会在 data 目录 下看到 mysql，perofrmance_schema，sys 目录，同时还会有一些文件。 六、安装 mysql 服务 mysqld -installmysqld -remove （出问题重新配置前需要卸载服务） 七、启动 mysql 服务、添加初始密码 net start mysqlmysqladmin -u root password 123456mysql -u root -p 八、设置默认编码先确保my.ini添加以下代码12345678[client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]default-character-set=utf8 或者 character-set-server=utf8 通过命令查看数据库当前编码 mysql -u root -pshow variables like ‘character%’; 如果不是以下编码，则设置编码12345678910111213+--------------------------+------------------------------------------------------------+| Variable_name | Value |+--------------------------+------------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | D:\Program Files\MySQL\mysql-5.7.22-winx64\share\charsets\ |+--------------------------+------------------------------------------------------------+8 rows in set, 1 warning (0.00 sec) 设置编码： SET character_set_client = utf8;SET character_set_connection = utf8;SET character_set_database = utf8;SET character_set_results = utf8;SET character_set_server = utf8; character_set_client为客户端编码方式； character_set_connection为建立连接使用的编码； character_set_database数据库的编码； character_set_results结果集的编码； character_set_server数据库服务器的编码； 九、mysql 开启远程连接 grant all privileges on *.* to ‘root‘@’%’ identified by ‘123456’ with grant option; 后记：如果中途有什么步骤失败，一定要执行 mysql 移除命令，然后删除 data 目录下的所有文件，然后删除服务 mysqld -remove特别提醒：5.7 和 5.6 不太相同，要自己初始化数据 data 目录，不然启动不会成功 十、后记mysql 安装完后可能会用到的语句123456789101112131415161718192021222324alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;123&apos;;create database victor;create user &apos;victor&apos;@&apos;localhost&apos; identified by &apos;victor@123&apos;;flush privileges;creaet user &apos;victorremote&apos;@&apos;%&apos; identified by &apos;victorremote@123&apos;;flush privileges;grant all on victor.* to &apos;victor&apos;@&apos;localhost&apos; identified by &apos;victor@123&apos;;flush privileges;grant all on victor.* to &apos;victorremote&apos;@&apos;%&apos; identified by &apos;victorremote@123&apos;;flush privileges;#################################连接最大空闲时长SHOW GLOBAL VARIABLES LIKE &apos;wait_timeout&apos;;#最大连接数SHOW VARIABLES LIKE &apos;%max_connections%&apos;;SET GLOBAL max_connections = 200;#字符编码SHOW VARIABLES WHERE Variable_name LIKE &apos;character\_set\_%&apos; OR Variable_name LIKE &apos;collation%&apos;;SHOW GLOBAL STATUS LIKE &apos;innodb_buffer_pool_pages_%&apos;;SHOW PROCESSLIST;SHOW STATUS LIKE &apos;Table%&apos;;SHOW STATUS LIKE &apos;%lock%&apos;;################################]]></content>
      <categories>
        <category>基础服务</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地图坐标转换]]></title>
    <url>%2F2017%2F09%2F24%2F2017-2017-09-24-%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[问题来源目前 IoT 领域各种智能设备都可以采集 GPS 数据，但是设备采集到的GPS都是 WGS-84 坐标系数据，在国内不能直接用于在地图上显示，需要进行一定转换。各地图工具都有坐标转换 API 可用，但是成千上万的 GPS 数据通过 API 转换是一件很消耗资源的事，所以需要提供一种离线转换的方式。 本人在项目中曾也用过 API 转换的方式，但是当设备数量一增加，在坐标转换这一个小功能上带来了巨大的资源开销，是一件很不划算事，因此想到利用算法替换 API 方式进行坐标转换。在查阅了一些资料和自己的整理后，进行了一下总结。 大地坐标系（WGS-84）大地坐标系是大地测量中以参考椭球面为基准面建立起来的坐标系。地面点的位置用大地经度、大地纬度和大地高度表示。大地坐标系的确立包括选择一个椭球、对椭球进行定位和确定大地起算数据。 火星坐标系（GCJ-02）是一种国家保密插件，也叫做加密插件或者加偏或者SM模组，其实就是对真实坐标系统进行人为的加偏处理，按照特殊的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被人称为火星坐标系统。所有的电子地图、导航设备，都需要加入国家保密插件。第一步，地图公司测绘地图，测绘完成后，送到国家测绘局，将真实坐标的电子地图，加密成“火星坐标”，这样的地图才是可以出版和发布的，然后才可以让GPS公司处理。第二步，所有的GPS公司，只要需要汽车导航的，需要用到导航电子地图的，都需要在软件中加入国家保密算法，将COM口读出来的真实的坐标信号，加密转换成国家要求的保密的坐标。这样，GPS导航仪和导航电子地图就可以完全匹配，GPS也就可以正常工作了。 百度坐标系（BD-09）百度坐标对火星坐标系进行了一次加密，形成了百度坐标系。 具体实现附上坐标转化详细 Java 版代码，Java 版本最低要求 Java 8代码中也提供了两种判断 WGS-84 坐标点是否在国内的方法，一种是很粗略的判断，另一种较为精确，但沿海、国界周边地区可能会有误差，更高精度需要自行调整坐标点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835/** * 地图坐标转换 * * @author Leaves * @version 1.0.0 * @date 2017/9/24 */public class GpsCoordinateUtil &#123; //private static final double PI = 3.1415926535897932384626433832795; private static final double PI = 3.14159265358979324; private static final double A = 6378245.0; private static final double EE = 0.00669342162296594323; /** * 地球坐标系 WGS-84 to 火星坐标系 GCJ-02 * * @param latitude 纬度 * @param longitude 经度 * @return [纬度, 经度] */ public static double[] calWGS84toGCJ02(double latitude, double longitude) &#123; Point dev = calDev(latitude, longitude); double retLat = latitude + dev.getLatitude(); double retLon = longitude + dev.getLongitude(); return new double[]&#123;retLat, retLon&#125;; &#125; /** * 地球坐标系 WGS-84 to 百度坐标系 BD-09 * * @param latitude 纬度 * @param longitude 经度 * @return [纬度, 经度] */ public static double[] calWGS84toBD09(double latitude, double longitude) &#123; Point dev = calDev(latitude, longitude); double retLat = latitude + dev.getLatitude(); double retLon = longitude + dev.getLongitude(); return calGCJ02toBD09(retLat, retLon); &#125; /** * 火星坐标系 GCJ-02 to 地球坐标系 WGS-84 * * @param latitude 纬度 * @param longitude 经度 * @return [纬度, 经度] */ public static double[] calGCJ02toWGS84(double latitude, double longitude) &#123; Point dev = calDev(latitude, longitude); double retLat = latitude - dev.getLatitude(); double retLon = longitude - dev.getLongitude(); dev = calDev(retLat, retLon); retLat = latitude - dev.getLatitude(); retLon = longitude - dev.getLongitude(); return new double[]&#123;retLat, retLon&#125;; &#125; /** * 百度坐标系 BD-09 to 地球坐标系 WGS-84 * * @param latitude 纬度 * @param longitude 经度 * @return [纬度, 经度] */ public static double[] calBD09toWGS84(double latitude, double longitude) &#123; double[] gcj = calBD09toGCJ02(latitude, longitude); return calGCJ02toWGS84(gcj[0], gcj[1]); &#125; private static Point calDev(double latitude, double longitude) &#123; if (isOutOfChina(latitude, longitude, false)) &#123; return new Point(0, 0); &#125; double dLat = calLat(longitude - 105.0, latitude - 35.0); double dLon = calLon(longitude - 105.0, latitude - 35.0); double radLat = latitude / 180.0 * PI; double magic = Math.sin(radLat); magic = 1 - EE * magic * magic; double sqrtMagic = Math.sqrt(magic); dLat = (dLat * 180.0) / ((A * (1 - EE)) / (magic * sqrtMagic) * PI); dLon = (dLon * 180.0) / (A / sqrtMagic * Math.cos(radLat) * PI); return new Point(dLat, dLon); &#125; private static double calLat(double x, double y) &#123; double ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x)); ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0; ret += (20.0 * Math.sin(y * PI) + 40.0 * Math.sin(y / 3.0 * PI)) * 2.0 / 3.0; ret += (160.0 * Math.sin(y / 12.0 * PI) + 320 * Math.sin(y * PI / 30.0)) * 2.0 / 3.0; return ret; &#125; private static double calLon(double x, double y) &#123; double ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x)); ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0; ret += (20.0 * Math.sin(x * PI) + 40.0 * Math.sin(x / 3.0 * PI)) * 2.0 / 3.0; ret += (150.0 * Math.sin(x / 12.0 * PI) + 300.0 * Math.sin(x / 30.0 * PI)) * 2.0 / 3.0; return ret; &#125; /** * 火星坐标系 GCJ-02 to 百度坐标系 BD-09 * * @param latitude 纬度 * @param longitude 经度 * @return [纬度, 经度] */ public static double[] calGCJ02toBD09(double latitude, double longitude) &#123; double x = longitude, y = latitude; double z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * PI); double theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * PI); double retLat = z * Math.sin(theta) + 0.006; double retLon = z * Math.cos(theta) + 0.0065; return new double[]&#123;retLat, retLon&#125;; &#125; /** * 百度坐标系 BD-09 to 火星坐标系 GCJ-02 * * @param latitude 纬度 * @param longitude 经度 * @return [纬度, 经度] */ public static double[] calBD09toGCJ02(double latitude, double longitude) &#123; double x = longitude - 0.0065, y = latitude - 0.006; double z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * PI); double theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * PI); double retLat = z * Math.sin(theta); double retLon = z * Math.cos(theta); return new double[]&#123;retLat, retLon&#125;; &#125; /** * 判断坐标是否在国内 * * @param latitude * @param longitude * @param precision 是否精确判断范围 * @return true 在国外，false 在国内 */ private static boolean isOutOfChina(double latitude, double longitude, boolean precision) &#123; if (precision) &#123; return CHINA_POLYGON.stream().noneMatch(point -&gt; pointInPolygon(point, latitude, longitude)); &#125; else &#123; if (longitude &lt; 72.004 || longitude &gt; 137.8347) &#123; return true; &#125; if (latitude &lt; 0.8293 || latitude &gt; 55.8271) &#123; return true; &#125; return false; &#125; &#125; /** * 检查坐标点是否在多边形区域内 * * @param polygon 多边形 * @param latitude 纬度 * @param longitude 经度 * @return true 在多边形区域内，false 在多边形区域外 */ private static boolean pointInPolygon(Point[] polygon, double latitude, double longitude) &#123; int i, j = polygon.length - 1; boolean oddNodes = false; for (i = 0; i &lt; polygon.length; i++) &#123; if ((polygon[i].getLatitude() &lt; latitude &amp;&amp; polygon[j].getLatitude() &gt;= latitude || polygon[j].getLatitude() &lt; latitude &amp;&amp; polygon[i].getLatitude() &gt;= latitude) &amp;&amp; (polygon[i].getLongitude() &lt;= longitude || polygon[j].getLongitude() &lt;= longitude)) &#123; if (polygon[i].getLongitude() + (latitude - polygon[i].getLatitude()) / (polygon[j].getLatitude() - polygon[i].getLatitude()) * (polygon[j].getLongitude() - polygon[i].getLongitude()) &lt; longitude) &#123; oddNodes = !oddNodes; &#125; &#125; j = i; &#125; return oddNodes; &#125; static class Point &#123; private double longitude; private double latitude; Point(double latitude, double longitude) &#123; this.longitude = longitude; this.latitude = latitude; &#125; public double getLongitude() &#123; return longitude; &#125; public void setLongitude(double longitude) &#123; this.longitude = longitude; &#125; public double getLatitude() &#123; return latitude; &#125; public void setLatitude(double latitude) &#123; this.latitude = latitude; &#125; @Override public String toString() &#123; return longitude + "," + latitude; &#125; &#125; //region 中国行政边界的WGS84坐标数据 //Mainland private static final Point[] MAINLAND = new Point[]&#123; new Point(27.32083, 88.91693), new Point(27.54243, 88.76464), new Point(28.00805, 88.83575), new Point(28.1168, 88.62435), new Point(27.86605, 88.14279), new Point(27.82305, 87.19275), new Point(28.11166, 86.69527), new Point(27.90888, 86.45137), new Point(28.15805, 86.19769), new Point(27.88625, 86.0054), new Point(28.27916, 85.72137), new Point(28.30666, 85.11095), new Point(28.59104, 85.19518), new Point(28.54444, 84.84665), new Point(28.73402, 84.48623), new Point(29.26097, 84.11651), new Point(29.18902, 83.5479), new Point(29.63166, 83.19109), new Point(30.06923, 82.17525), new Point(30.33444, 82.11123), new Point(30.385, 81.42623), new Point(30.01194, 81.23221), new Point(30.20435, 81.02536), new Point(30.57552, 80.207), new Point(30.73374, 80.25423), new Point(30.96583, 79.86304), new Point(30.95708, 79.55429), new Point(31.43729, 79.08082), new Point(31.30895, 78.76825), new Point(31.96847, 78.77075), new Point(32.24304, 78.47594), new Point(32.5561, 78.40595), new Point(32.63902, 78.74623), new Point(32.35083, 78.9711), new Point(32.75666, 79.52874), new Point(33.09944, 79.37511), new Point(33.42863, 78.93623), new Point(33.52041, 78.81387), new Point(34.06833, 78.73581), new Point(34.35001, 78.98535), new Point(34.6118, 78.33707), new Point(35.28069, 78.02305), new Point(35.49902, 78.0718), new Point(35.50133, 77.82393), new Point(35.6125, 76.89526), new Point(35.90665, 76.55304), new Point(35.81458, 76.18061), new Point(36.07082, 75.92887), new Point(36.23751, 76.04166), new Point(36.66343, 75.85984), new Point(36.73169, 75.45179), new Point(36.91156, 75.39902), new Point(36.99719, 75.14787), new Point(37.02782, 74.56543), new Point(37.17, 74.39089), new Point(37.23733, 74.91574), new Point(37.40659, 75.18748), new Point(37.65243, 74.9036), new Point(38.47256, 74.85442), new Point(38.67438, 74.35471), new Point(38.61271, 73.81401), new Point(38.88653, 73.70818), new Point(38.97256, 73.85235), new Point(39.23569, 73.62005), new Point(39.45483, 73.65569), new Point(39.59965, 73.95471), new Point(39.76896, 73.8429), new Point(40.04202, 73.99096), new Point(40.32792, 74.88089), new Point(40.51723, 74.8588), new Point(40.45042, 75.23394), new Point(40.64452, 75.58284), new Point(40.298, 75.70374), new Point(40.35324, 76.3344), new Point(41.01258, 76.87067), new Point(41.04079, 78.08083), new Point(41.39286, 78.39554), new Point(42.03954, 80.24513), new Point(42.19622, 80.23402), new Point(42.63245, 80.15804), new Point(42.81565, 80.25796), new Point(42.88545, 80.57226), new Point(43.02906, 80.38405), new Point(43.1683, 80.81526), new Point(44.11378, 80.36887), new Point(44.6358, 80.38499), new Point(44.73408, 80.51589), new Point(44.90282, 79.87106), new Point(45.3497, 81.67928), new Point(45.15748, 81.94803), new Point(45.13303, 82.56638), new Point(45.43581, 82.64624), new Point(45.5831, 82.32179), new Point(47.20061, 83.03443), new Point(46.97332, 83.93026), new Point(46.99361, 84.67804), new Point(46.8277, 84.80318), new Point(47.0591, 85.52257), new Point(47.26221, 85.70139), new Point(47.93721, 85.53707), new Point(48.39333, 85.76596), new Point(48.54277, 86.59791), new Point(49.1102, 86.87602), new Point(49.09262, 87.34821), new Point(49.17295, 87.8407), new Point(48.98304, 87.89291), new Point(48.88103, 87.7611), new Point(48.73499, 88.05942), new Point(48.56541, 87.99194), new Point(48.40582, 88.51679), new Point(48.21193, 88.61179), new Point(47.99374, 89.08514), new Point(47.88791, 90.07096), new Point(46.95221, 90.9136), new Point(46.57735, 91.07027), new Point(46.29694, 90.92151), new Point(46.01735, 91.02651), new Point(45.57972, 90.68193), new Point(45.25305, 90.89694), new Point(45.07729, 91.56088), new Point(44.95721, 93.5547), new Point(44.35499, 94.71735), new Point(44.29416, 95.41061), new Point(44.01937, 95.34109), new Point(43.99311, 95.53339), new Point(43.28388, 95.87901), new Point(42.73499, 96.38206), new Point(42.79583, 97.1654), new Point(42.57194, 99.51012), new Point(42.67707, 100.8425), new Point(42.50972, 101.8147), new Point(42.23333, 102.0772), new Point(41.88721, 103.4164), new Point(41.87721, 104.5267), new Point(41.67068, 104.5237), new Point(41.58666, 105.0065), new Point(42.46624, 107.4758), new Point(42.42999, 109.3107), new Point(42.64576, 110.1064), new Point(43.31694, 110.9897), new Point(43.69221, 111.9583), new Point(44.37527, 111.4214), new Point(45.04944, 111.873), new Point(45.08055, 112.4272), new Point(44.8461, 112.853), new Point(44.74527, 113.638), new Point(45.38943, 114.5453), new Point(45.4586, 115.7019), new Point(45.72193, 116.2104), new Point(46.29583, 116.5855), new Point(46.41888, 117.3755), new Point(46.57069, 117.425), new Point(46.53645, 117.8455), new Point(46.73638, 118.3147), new Point(46.59895, 119.7068), new Point(46.71513, 119.9315), new Point(46.90221, 119.9225), new Point(47.66499, 119.125), new Point(47.99475, 118.5393), new Point(48.01125, 117.8046), new Point(47.65741, 117.3827), new Point(47.88805, 116.8747), new Point(47.87819, 116.2624), new Point(47.69186, 115.9231), new Point(47.91749, 115.5944), new Point(48.14353, 115.5491), new Point(48.25249, 115.8358), new Point(48.52055, 115.8111), new Point(49.83047, 116.7114), new Point(49.52058, 117.8747), new Point(49.92263, 118.5746), new Point(50.09631, 119.321), new Point(50.33028, 119.36), new Point(50.39027, 119.1386), new Point(51.62083, 120.0641), new Point(52.115, 120.7767), new Point(52.34423, 120.6259), new Point(52.54267, 120.7122), new Point(52.58805, 120.0819), new Point(52.76819, 120.0314), new Point(53.26374, 120.8307), new Point(53.54361, 123.6147), new Point(53.18832, 124.4933), new Point(53.05027, 125.62), new Point(52.8752, 125.6573), new Point(52.75722, 126.0968), new Point(52.5761, 125.9943), new Point(52.12694, 126.555), new Point(51.99437, 126.4412), new Point(51.38138, 126.9139), new Point(51.26555, 126.8176), new Point(51.31923, 126.9689), new Point(51.05825, 126.9331), new Point(50.74138, 127.2919), new Point(50.31472, 127.334), new Point(50.20856, 127.5861), new Point(49.80588, 127.515), new Point(49.58665, 127.838), new Point(49.58443, 128.7119), new Point(49.34676, 129.1118), new Point(49.4158, 129.4902), new Point(48.86464, 130.2246), new Point(48.86041, 130.674), new Point(48.60576, 130.5236), new Point(48.3268, 130.824), new Point(48.10839, 130.6598), new Point(47.68721, 130.9922), new Point(47.71027, 132.5211), new Point(48.09888, 133.0827), new Point(48.06888, 133.4843), new Point(48.39112, 134.4153), new Point(48.26713, 134.7408), new Point(47.99207, 134.5576), new Point(47.70027, 134.7608), new Point(47.32333, 134.1825), new Point(46.64017, 133.9977), new Point(46.47888, 133.8472), new Point(46.25363, 133.9016), new Point(45.82347, 133.4761), new Point(45.62458, 133.4702), new Point(45.45083, 133.1491), new Point(45.05694, 133.0253), new Point(45.34582, 131.8684), new Point(44.97388, 131.4691), new Point(44.83649, 130.953), new Point(44.05193, 131.298), new Point(43.53624, 131.1912), new Point(43.38958, 131.3104), new Point(42.91645, 131.1285), new Point(42.74485, 130.4327), new Point(42.42186, 130.6044), new Point(42.71416, 130.2468), new Point(42.88794, 130.2514), new Point(43.00457, 129.9046), new Point(42.43582, 129.6955), new Point(42.44624, 129.3493), new Point(42.02736, 128.9269), new Point(42.00124, 128.0566), new Point(41.58284, 128.3002), new Point(41.38124, 128.1529), new Point(41.47249, 127.2708), new Point(41.79222, 126.9047), new Point(41.61176, 126.5661), new Point(40.89694, 126.0118), new Point(40.47037, 124.8851), new Point(40.09362, 124.3736), new Point(39.82777, 124.128), new Point(39.8143, 123.2422), new Point(39.67388, 123.2167), new Point(38.99638, 121.648), new Point(38.8611, 121.6982), new Point(38.71909, 121.1873), new Point(38.91221, 121.0887), new Point(39.09013, 121.6794), new Point(39.2186, 121.5994), new Point(39.35166, 121.7511), new Point(39.52847, 121.2283), new Point(39.62322, 121.533), new Point(39.81138, 121.4683), new Point(40.00305, 121.881), new Point(40.50562, 122.2987), new Point(40.73874, 122.0521), new Point(40.92194, 121.1775), new Point(40.1961, 120.4468), new Point(39.87242, 119.5264), new Point(39.15693, 118.9715), new Point(39.04083, 118.3273), new Point(39.19846, 117.889), new Point(38.67555, 117.5364), new Point(38.38666, 117.6722), new Point(38.16721, 118.0281), new Point(38.1529, 118.8378), new Point(37.87832, 119.0355), new Point(37.30054, 118.9566), new Point(37.14361, 119.2328), new Point(37.15138, 119.7672), new Point(37.35228, 119.8529), new Point(37.83499, 120.7371), new Point(37.42458, 121.58), new Point(37.55256, 122.1282), new Point(37.41833, 122.1814), new Point(37.39624, 122.5586), new Point(37.20999, 122.5972), new Point(37.02583, 122.4005), new Point(37.01978, 122.5392), new Point(36.89361, 122.5047), new Point(36.84298, 122.1923), new Point(37.00027, 121.9566), new Point(36.75889, 121.5944), new Point(36.61666, 120.7764), new Point(36.52638, 120.96), new Point(36.37582, 120.8753), new Point(36.42277, 120.7062), new Point(36.14075, 120.6956), new Point(36.0419, 120.3436), new Point(36.26345, 120.3078), new Point(36.19998, 120.0889), new Point(35.95943, 120.2378), new Point(35.57893, 119.6475), new Point(34.88499, 119.1761), new Point(34.31145, 120.2487), new Point(32.97499, 120.8858), new Point(32.63889, 120.8375), new Point(32.42958, 121.3348), new Point(32.11333, 121.4412), new Point(32.02166, 121.7066), new Point(31.67833, 121.8275), new Point(31.86639, 120.9444), new Point(32.09361, 120.6019), new Point(31.94555, 120.099), new Point(32.30638, 119.8267), new Point(32.26277, 119.6317), new Point(31.90388, 120.1364), new Point(31.98833, 120.7026), new Point(31.81944, 120.7196), new Point(31.30889, 121.6681), new Point(30.97986, 121.8828), new Point(30.85305, 121.8469), new Point(30.56889, 120.9915), new Point(30.33555, 120.8144), new Point(30.39298, 120.4586), new Point(30.19694, 120.15), new Point(30.31027, 120.5082), new Point(30.06465, 120.7916), new Point(30.30458, 121.2808), new Point(29.96305, 121.6778), new Point(29.88211, 122.1196), new Point(29.51167, 121.4483), new Point(29.58916, 121.9744), new Point(29.19527, 121.9336), new Point(29.18388, 121.8119), new Point(29.37236, 121.7969), new Point(29.19729, 121.7444), new Point(29.29111, 121.5611), new Point(29.1634, 121.4135), new Point(29.02194, 121.6914), new Point(28.9359, 121.4908), new Point(28.72798, 121.6113), new Point(28.84215, 121.1464), new Point(28.66993, 121.4844), new Point(28.34722, 121.6417), new Point(28.13889, 121.3419), new Point(28.38277, 121.1651), new Point(27.98222, 120.9353), new Point(28.07944, 120.5908), new Point(27.87229, 120.84), new Point(27.59319, 120.5812), new Point(27.45083, 120.6655), new Point(27.20777, 120.5075), new Point(27.28278, 120.1896), new Point(27.14764, 120.4211), new Point(26.89805, 120.0332), new Point(26.64465, 120.128), new Point(26.51778, 119.8603), new Point(26.78823, 120.0733), new Point(26.64888, 119.8668), new Point(26.79611, 119.7879), new Point(26.75625, 119.5503), new Point(26.44222, 119.8204), new Point(26.47388, 119.5775), new Point(26.33861, 119.658), new Point(26.36777, 119.9489), new Point(25.99694, 119.4253), new Point(26.14041, 119.0975), new Point(25.93788, 119.354), new Point(25.99069, 119.7058), new Point(25.67996, 119.5807), new Point(25.68222, 119.4522), new Point(25.35333, 119.6454), new Point(25.60649, 119.3149), new Point(25.42097, 119.1053), new Point(25.25319, 119.3526), new Point(25.17208, 119.2726), new Point(25.2426, 118.8749), new Point(24.97194, 118.9866), new Point(24.88291, 118.5729), new Point(24.75673, 118.7631), new Point(24.52861, 118.5953), new Point(24.53638, 118.2397), new Point(24.68194, 118.1688), new Point(24.44024, 118.0199), new Point(24.46019, 117.7947), new Point(24.25875, 118.1237), new Point(23.62437, 117.1957), new Point(23.65919, 116.9179), new Point(23.355, 116.7603), new Point(23.42024, 116.5322), new Point(23.23666, 116.7871), new Point(23.21083, 116.5139), new Point(22.93902, 116.4817), new Point(22.73916, 115.7978), new Point(22.88416, 115.6403), new Point(22.65889, 115.5367), new Point(22.80833, 115.1614), new Point(22.70277, 114.8889), new Point(22.53305, 114.8722), new Point(22.64027, 114.718), new Point(22.81402, 114.7782), new Point(22.69972, 114.5208), new Point(22.50423, 114.6136), new Point(22.55004, 114.2223), new Point(22.42993, 114.3885), new Point(22.26056, 114.2961), new Point(22.36736, 113.9056), new Point(22.50874, 114.0337), new Point(22.47444, 113.8608), new Point(22.83458, 113.606), new Point(23.05027, 113.5253), new Point(23.11724, 113.8219), new Point(23.05083, 113.4793), new Point(22.87986, 113.3629), new Point(22.54944, 113.5648), new Point(22.18701, 113.5527), new Point(22.56701, 113.1687), new Point(22.17965, 113.3868), new Point(22.04069, 113.2226), new Point(22.20485, 113.0848), new Point(21.8693, 112.94), new Point(21.96472, 112.824), new Point(21.70139, 112.2819), new Point(21.91611, 111.8921), new Point(21.75139, 111.9669), new Point(21.77819, 111.6762), new Point(21.61264, 111.7832), new Point(21.5268, 111.644), new Point(21.52528, 111.0285), new Point(21.21138, 110.5328), new Point(21.37322, 110.3944), new Point(20.84381, 110.1594), new Point(20.84083, 110.3755), new Point(20.64, 110.3239), new Point(20.48618, 110.5274), new Point(20.24611, 110.2789), new Point(20.2336, 109.9244), new Point(20.4318, 110.0069), new Point(20.92416, 109.6629), new Point(21.44694, 109.9411), new Point(21.50569, 109.6605), new Point(21.72333, 109.5733), new Point(21.49499, 109.5344), new Point(21.39666, 109.1428), new Point(21.58305, 109.1375), new Point(21.61611, 108.911), new Point(21.79889, 108.8702), new Point(21.59888, 108.7403), new Point(21.93562, 108.4692), new Point(21.59014, 108.5125), new Point(21.68999, 108.3336), new Point(21.51444, 108.2447), new Point(21.54241, 107.99), new Point(21.66694, 107.7831), new Point(21.60526, 107.3627), new Point(22.03083, 106.6933), new Point(22.45682, 106.5517), new Point(22.76389, 106.7875), new Point(22.86694, 106.7029), new Point(22.91253, 105.8771), new Point(23.32416, 105.3587), new Point(23.18027, 104.9075), new Point(22.81805, 104.7319), new Point(22.6875, 104.3747), new Point(22.79812, 104.1113), new Point(22.50387, 103.9687), new Point(22.78287, 103.6538), new Point(22.58436, 103.5224), new Point(22.79451, 103.3337), new Point(22.43652, 103.0304), new Point(22.77187, 102.4744), new Point(22.39629, 102.1407), new Point(22.49777, 101.7415), new Point(22.20916, 101.5744), new Point(21.83444, 101.7653), new Point(21.14451, 101.786), new Point(21.17687, 101.2919), new Point(21.57264, 101.1482), new Point(21.76903, 101.099), new Point(21.47694, 100.6397), new Point(21.43546, 100.2057), new Point(21.72555, 99.97763), new Point(22.05018, 99.95741), new Point(22.15592, 99.16785), new Point(22.93659, 99.56484), new Point(23.08204, 99.5113), new Point(23.18916, 98.92747), new Point(23.97076, 98.67991), new Point(24.16007, 98.89073), new Point(23.92999, 97.54762), new Point(24.26055, 97.7593), new Point(24.47666, 97.54305), new Point(24.73992, 97.55255), new Point(25.61527, 98.19109), new Point(25.56944, 98.36137), new Point(25.85597, 98.7104), new Point(26.12527, 98.56944), new Point(26.18472, 98.73109), new Point(26.79166, 98.77777), new Point(27.52972, 98.69699), new Point(27.6725, 98.45888), new Point(27.54014, 98.31992), new Point(28.14889, 98.14499), new Point(28.54652, 97.55887), new Point(28.22277, 97.34888), new Point(28.46749, 96.65387), new Point(28.35111, 96.40193), new Point(28.525, 96.34027), new Point(28.79569, 96.61373), new Point(29.05666, 96.47083), new Point(28.90138, 96.17532), new Point(29.05972, 96.14888), new Point(29.25757, 96.39172), new Point(29.46444, 96.08315), new Point(29.03527, 95.38777), new Point(29.33346, 94.64751), new Point(29.07348, 94.23456), new Point(28.6692, 93.96172), new Point(28.61876, 93.35194), new Point(28.3193, 93.22205), new Point(28.1419, 92.71044), new Point(27.86194, 92.54498), new Point(27.76472, 91.65776), new Point(27.945, 91.66277), new Point(28.08111, 91.30138), new Point(27.96999, 91.08693), new Point(28.07958, 90.3765), new Point(28.24257, 90.38898), new Point(28.32369, 89.99819), new Point(28.05777, 89.48749), new Point(27.32083, 88.91693) &#125;; //Taiwan private static final Point[] TAIWAN = new Point[]&#123; new Point(25.13474, 121.4441), new Point(25.28361, 121.5632), new Point(25.00722, 122.0004), new Point(24.85028, 121.8182), new Point(24.47638, 121.8397), new Point(23.0875, 121.3556), new Point(21.92791, 120.7196), new Point(22.31277, 120.6103), new Point(22.54044, 120.3071), new Point(23.04437, 120.0539), new Point(23.61708, 120.1112), new Point(25.00166, 121.0017), new Point(25.13474, 121.4441) &#125;; //Hainan private static final Point[] HAINAN = new Point[]&#123; new Point(19.52888, 110.855), new Point(19.16761, 110.4832), new Point(18.80083, 110.5255), new Point(18.3852, 110.0503), new Point(18.39152, 109.7594), new Point(18.19777, 109.7036), new Point(18.50562, 108.6871), new Point(19.28028, 108.6283), new Point(19.76, 109.2939), new Point(19.7236, 109.1653), new Point(19.89972, 109.2572), new Point(19.82861, 109.4658), new Point(19.99389, 109.6108), new Point(20.13361, 110.6655), new Point(19.97861, 110.9425), new Point(19.63829, 111.0215), new Point(19.52888, 110.855) &#125;; //Chongming private static final Point[] CHONGMING = new Point[]&#123; new Point(31.80054, 121.2039), new Point(31.49972, 121.8736), new Point(31.53111, 121.5464), new Point(31.80054, 121.2039) &#125;; //endregion /** * 中国行政边界的WGS84坐标数据， * 光线投射算法 (Ray casting algorithm) 获得， * 沿海、国界周边地区可能会有误差，更高精度需要调整坐标点 */ private static final List&lt;Point[]&gt; CHINA_POLYGON = new ArrayList&lt;&gt;(); static &#123; CHINA_POLYGON.add(MAINLAND); CHINA_POLYGON.add(TAIWAN); CHINA_POLYGON.add(HAINAN); CHINA_POLYGON.add(CHONGMING); &#125; public static void main(String[] args) &#123; // WGS84坐标: 30.256676, 120.149987 Point gps = new Point(30.256676, 120.149987); System.out.println("WGS84 : " + gps); double[] wgsToGcj = calWGS84toGCJ02(gps.getLatitude(), gps.getLongitude()); System.out.println("WGS84 -&gt; GCJ02 : " + wgsToGcj[1] + "," + wgsToGcj[0]); double[] wgsToBd = calWGS84toBD09(gps.getLatitude(), gps.getLongitude()); System.out.println("WGS84 -&gt; BD09 : " + wgsToBd[1] + "," + wgsToBd[0]); double[] gcjToWgs = calGCJ02toWGS84(wgsToGcj[0], wgsToGcj[1]); System.out.println("GCJ02 -&gt; WGS84 : " + gcjToWgs[1] + "," + gcjToWgs[0]); double[] bdToWgs = calBD09toWGS84(wgsToBd[0], wgsToBd[1]); System.out.println("BD09 -&gt; WGS84 : " + bdToWgs[1] + "," + bdToWgs[0]); double[] gcjToBd = calGCJ02toBD09(wgsToGcj[0], wgsToGcj[1]); System.out.println("GCJ02 -&gt; BD09 : " + gcjToBd[1] + "," + gcjToBd[0]); double[] bdToGcj = calBD09toGCJ02(wgsToBd[0], wgsToBd[1]); System.out.println("BD09 -&gt; GCJ02 : " + bdToGcj[1] + "," + bdToGcj[0]); Long start = System.nanoTime(); System.out.println("OutOfChina : " + isOutOfChina(30.256676, 120.149987, true) + ", " + (System.nanoTime() - start) + " ns"); &#125;&#125; 参考与感谢 Darel Rex Finley : Point-In-Polygon AlgorithmAimeast : 【WP7】判断GPS坐标是否在中国]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>地图</tag>
        <tag>gps</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 修改控制台字体]]></title>
    <url>%2F2017%2F05%2F07%2F2017-2017-05-07-Windows-10-%E4%BF%AE%E6%94%B9%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[用过 Mac、Linux 的用户都会觉得这两个系统的 Terminal 字体相比 Windows 的看起来舒服很多，其实 Windows 控制台字体也是可以更改的，比如更改成等宽字体，下面的是更改方法，可以参考。控制台背景改成白色，字体改成黑色显示效果更佳。推荐一款字体：Menlo字体下载：点击下载 Win+R: regedit，打开注册表编辑器添加字体[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Console\TrueTypeFont]添加字符串值: “000” -&gt; Menlo (自选字体) 修改字符编码[HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe]修改 “CodePage”=REG_DWORD: 0x0000fde9 (65001)添加(可选) “FaceName”=REG_SZ: Menlo 【注】十六进制”000003a8”或十进制”936”，表示“936 (ANSI/OEM - 简体中文 GBK)” ————————————– END ————————————– 附: chcp详解功能说明显示活动控制台代码页数量，或更改该控制台的活动控制台代码页。如果在没有参数的情况下使用，则 chcp 显示活动控制台代码页的数量。 补充说明只有随 XOX 一起安装的原始设备制造商 (OEM) 代码页才能在使用 Raster 字体的命令提示符窗口中正常显示。其他代码页则可在全屏幕模式下或者在使用 TrueType 字体的命令提示符窗口中正确显示。 就像在 MS-DOS 中一样，您不必准备代码页。 在指派了新代码页之后启动的程序将使用该新代码页，但如果程序（除了 cmd.exe）是在指派新代码页之前启动的，那么该程序将使用原来的代码页。 语法chcp [NNN] 参数NNN 指定代码页。下表列出了MSDOS所有支持的代码页及其国家（地区）或者语言：代码页 国家（地区）或语言437 美国850 多语言（拉丁文 I）852 斯拉夫语（拉丁文 II）855 西里尔文（俄语）857 土耳其语860 葡萄牙语861 冰岛语863 加拿大 - 法语865 日耳曼语866 俄语869 现代希腊语936 简体中文950 繁体中文65001 UTF-8 /? 在命令提示符下显示帮助。 示例： 要查看活动代码页设置，请键入：chcp 出现类似于下面内容的消息：活动代码页：437 如果要将活动代码页更改为 850（多语言），请键入：chcp 850 如果指定的代码页无效，则会显示以下错误消息：无效代码页]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
</search>
